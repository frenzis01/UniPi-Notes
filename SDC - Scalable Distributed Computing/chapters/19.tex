\chapter{Vertex Centric Computing}
\label{chap:vertex-centric-computing}

This lecture was held by Emanuele Carlini.

The lecture spans in three sections:
\begin{enumerate}
   \item Introduction to vertex-centric computing
   \item Real stuff from Paper
   \item Talk about thesis projects.
\end{enumerate}

\section{Introduction to vertex-centric computing}

Vertex-centric computing takes a bit from Distributed computing, Graph theory, and Big Data.

\subsection{Graph Theory}
First, let'address graphs. Graphs are typically defined as $G = (V, E)$, where $V$ is the set of vertices, and $E$ is the set of edges. Edges can be directed or undirected, and can have weights.\\
Vertices have a in/out\footnote{In case of a directed graph} degree.

Edges typically represent the relationships between vertices.

\begin{definition}
   [Graph Theory]
   Graph theory is a branch of mathematics that studies graphs, which are mathematical structures used to model pairwise relations between objects.
\end{definition}
\note{Hence, GT deals with Connectivity, Flows, Topology, and many other things.}

\subsubsection{Topologies}
\begin{itemize}
   \item \textbf{Random graphs} - Every edge has a probability $p$ of being present.
   \item \textbf{Small-world graphs} - Most nodes can be reached from every other node by a small number of hops.
   \item \textbf{Preferential attachment} - New nodes prefer to connect to nodes with high degree.
\end{itemize}

% // TODO

\subsection{Towards Vertex-Centric}

\begin{definition}
   [Vertex-Centric]
   Vertex-centric computing is a programming model for graph processing that allows the user to define a function that is executed on each vertex of the graph.
\end{definition}

\begin{lstlisting}[caption={TLAV in a nutshell}]
for each iteration
   for each vertex v
      fetch data from neighbors
      update internal state
      send data to neighbors
\end{lstlisting}
Note that each node can know something without seeing the whole network.

TLAV's logic is very simple and straightforward, making it very flexible; it may be applied to:\ns
\begin{itemize}
   \item Decentralized networks (one host = one node)
   \item Distributed networks (one host = multiple nodes)
   \item Multi-core machines (one core = multiple nodes)
\end{itemize}

\section{Practical Examples}

\subsection{Fast Connected Components Computing in Large Graphs by Vertex Pruning}
A paper by Emanuele Carlini, Alessandro Lulli, Patrizio Dazzi, Claudio Lucchese and Laura Ricci.

\begin{definition}
   [Connected Component]
   A \textbf{Connected Component} (\texttt{CC}) in an \textit{undirected graph} is a maximal subset of vertices in which there is a path between any pair of vertices. In \textit{directed graphs}, we distinguish between \textbf{Strongly Connected Components} (SCC, with directed paths in both directions) and \textbf{Weakly Connected Components} (ignoring edge direction).
\end{definition}

\textbf{Note}: A Connected Component is different from a \textbf{knot} (as seen in deadlock detection in directed graphs). In undirected graphs, a CC is based on bidirectional connectivity. A knot (in directed graphs) requires that every node has at least one outgoing edge to another node in the subset, forming a cyclic structure. While a knot is always within a (weakly) connected component, a connected component is not necessarily a knot.

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[
    node distance=2cm,
    vertex/.style={circle, draw, minimum size=0.8cm, font=\small},
    arrow/.style={->, >=stealth, thick},
    edge/.style={-, thick}
]

% Undirected graph - Connected Component (not a knot)
\node[vertex] (A) at (0,0) {A};
\node[vertex] (B) at (2,0) {B};
\node[vertex] (C) at (4,0) {C};

\draw[edge] (A) -- (B);
\draw[edge] (B) -- (C);

\node[above=0.3cm of B, font=\small\bfseries] {Undirected: CC (NOT a knot)};
\node[below=0.5cm of B, font=\scriptsize, align=center] {All nodes connected (undirected),\\linear structure};

% Directed graph - Knot (which is also a weakly CC)
\node[vertex] (D) at (7,0) {D};
\node[vertex] (E) at (9,0) {E};
\node[vertex] (F) at (8,-1.5) {F};

\draw[arrow] (D) -- (E);
\draw[arrow] (E) -- (F);
\draw[arrow] (F) -- (D);

\node[above=0.3cm of E, font=\small\bfseries] {Directed: Knot (SCC)};
\node[below=0.3cm of F, font=\scriptsize, align=center] {Every node has outgoing edge,\\forms a cycle};

\end{tikzpicture}
\caption{Difference between Connected Component and Knot: the left shows an undirected CC (linear structure, paths exist in both directions due to undirected edges), while the right shows a directed knot which is also a Strongly Connected Component (cyclic structure with directed paths)}
\label{fig:19/cc-vs-knot}
\end{figure}

The paper talks about an algorithm called \textit{``Cracker''}, which is a vertex-centric algorithm to find connected components in undirected graphs, which exploits an \textbf{incremental} approach and \textbf{message passing} to achieve its goal.

\begin{paracol}{2}
   \colfill
   The key idea is to incrementally remove nodes when we are sure of their \texttt{CC}. 
   Each CC is identified by a unique ID.
   Each iteration takes less time than the previous one.
   \colfill
   \switchcolumn
   \begin{lstlisting}
      while (not finished)
         // find the seeds
         selection()
         simplification()
      // propagate the seeds
      propagation()
   \end{lstlisting}
\end{paracol}

This was used as backend for a web page crawler.
Many web pages were represented as nodes, with edges representing similarities computed with locality-sensitive hashing (was this the name?).

Computing the CCs allowed to group similar pages together, and perform more specific heuristics on them, which, being polynomial (worse than linear) would have taken too much time to be performed on the whole graph.

\subsection{Decentralized minimum vertex cover}
\begin{definition}
   [Vertex Cover]
   A \textbf{Vertex Cover} on an undirected graph G is a subset C of the nodes of the graph, such that for each edge, at least one endpoint of the edge is included in C. The minimum vertex cover problem consists in finding the C of minimum size.
\end{definition}


\begin{itemize}
   \item Every node starts as deselected.
   \item Superstep 1 - Mark as selected the node with the highest degree among the neighbors and the node itself
   \item If the node is selected or all of its neighbors are, do nothing
   \item Superstep 2 - Otherwise, select among all non selected neighbors, the one with the best gain, until you find a worst neighbor, and select yourself.
   \item Superstep 3 - If the node and all its neighbors are selected, deselect the node
\end{itemize}