\chapter{Tools for DHT and Blockchains}
\section{Cryptographic Tools}
\begin{definition}[Hash Function]
   An hash function converts a binary string of arbitrary length to a binary string of fixed length
\end{definition}

\subsection{Hash functions and collisions}
Non-crypto hash functions have low collision probability, but still for an adversary specifically looking to produce one, it may be easy to succeed.\\
For example, the \textit{Cyclic Redundancy Check} (\texttt{CRC}) ---which essentially is the remainder in a long division calculation--- was long mistakenly used where instead crypto integrity was required.
Even if it is unlinkely to generate a collision using random errors, it is reasonably easy for an adversary to find one. 

Note that \ul{collisions \textit{always} exist}, because the codomain is always smaller than the domain of the function.
The term \textbf{hash security} refers to how hard is to \textit{find} a collision for a given hash function.


\subsection{Cryptographic Hash functions}
Two main properties must hold for an HF to be cryptographic:
\begin{enumerate}
   \item \textbf{Adversarial collision resistance}
   \item \textbf{One way function}
\end{enumerate}

These are formalized as:
\begin{enumerate}
   \item \textit{Pre-image} resistance\\
   $\forall y \in Y. \textit{hard to find } x \in X s.t. h(x) = y$
   \note{\textit{``one-way function''}}
   \item \textit{Second pre-image} resistance
   $\textit{given } x \in X, y = h(x). \textit{hard to find } x' \in X s.t. h(x') = y$
   \note{Also called \textit{\ul{weak} collision resistance}}  
   \item \textit{Collision} resistance
   $\textit{Hard to find} x_1,x_2 \in X. x_1 \neq x_2 \wedge h(x_1) = h(x_2)$
   \note{Also called \textit{\ul{strong} collision resistance}}
\end{enumerate}

Given a $m-bit$ hash function, the attacker needs $2^{m/2}$ brute force computation to
find a collision.

\subsection{Hiding and Puzzles}
For cryptocurrencies and blockchains also \textbf{hiding} and \textbf{puzzle-friendliness} are required.
\begin{definition}[Hiding]
a hash function $H$ is said to be hiding when a secret value $R$ is chosen from
a probability distribution that has high min-entropy, then, given  $H(R || x)$, it is infeasible to find $x$
\end{definition}
\nl

A hash/search puzzle consists of:
\begin{itemize}
   \item Cryptographic hash function, $H$
   \item Random value, $r$
   \item Target set, $S$
   \item Solution of the puzzle is a value $x$, such that:
   $m = r || x \wedge H(m) \in S$
\end{itemize}
Bitcoin \textit{Proof of Work} (\textbf{PoW}) is based on a hash/search puzzle.
\begin{definition}[Puzzle friendliness]
   H is said to be puzzle friendly if:
   \begin{itemize}
      \item For every possible n-bit output value $y$, if $k$ is chosen from a distribution with high min entropy, then it is \ul{infeasible to find $x$ such that $H(k || x) = y$ in time significantly less than $2^n$}.
   \end{itemize}
\end{definition}
Puzzle-friendly property implies that
\textit{no} solving strategy to solve a search puzzle is much better than \textit{trying exaustively} all the values $x \in X$.

TODO
Complete lecture on Cryptographic Tools

\section{Data Structures}

\subsection{Bloom Filters}
\textbf{Bloom Filters} answers queries like \textit{``is $k$ an element of $S$''}; they assess the \textit{Set Membership} problem. Bloom filters are fast and lightweight but provide a proabilistic answer
\begin{equation}
   BF(k) = 
   \begin{cases*}
      $0$ & $k \notin S$\\
      $1$ & $k \textit{ \ul{may be} in } S$  
   \end{cases*}   
\end{equation}
The probability of false positives is
\begin{equation*}
   p' = \left( 1 - \frac{1}{m}\right) ^{kn} \approx e^{-kn/m}
\end{equation*}

A common use of BFs is to perform the \textbf{intersection} between them.
They are used by Ethereum, Google, and Bitcoin.

\subsection{Merkle Hash Table}
It is a data structure summarizing a big quantity of data, with the goal of verifying the correctness of the content.
A \textbf{Merkle Hash Table} consists of a complete binary tree of hashes built starting from an initial set of data:
\begin{itemize}
   \item $i^{th}$ leaf stores the hash $h_i$ of $f_i$ 
   \item An internal node contains the concatenation of the hashes of the sons of the node
   \item The last hash stored in the root is called \textit{Merkle Root Hash}
\end{itemize}

A \ul{collision-resistant hash function \textit{Merkle Hash Tree} (\texttt{MHT}) takes $n$ inputs $(x_1,\dots,x_n)$ and outputs a Merkle root hash $h=MHT(x_1,\dots,x_n)$}. Such function has an important property:
has an important property: 
\begin{center}
   Imagine Alice (\textit{verifier}) knows only the Merkle root hash $h$;\\
   Bob (\textit{prover}) can give Alice one of the values $x_i$ and convince Alice that it was the $i^{th}$ input used to compute $h$.
   To convince her, Bob gives Alice an associated Merkle proof without
   showing all the other inputs;
   if a Merkle proof says that $x_i$ was the $i^{th}$ input used to computed $h$, no attacker can come up with another Merkle proof that says a different $x'_i\neq x_i$ was the $i^{th}$ input uses in MHT
\end{center}