\chapter{Functional Programming}
\textbf{Functional Programming} languages radicate their roots in the Church's model of computing known as \textbf{\textit{lambda calculus}}.
Such model is based on the notion $\Lambda-\textit{parametrized}$ \textit{expressions},
with the focus on defining mathemtical functions in a constructive and effective way.
The computation proceeds by substituting parameters into expressions.\nl

Functional programming languages such as \textit{Lisp, Scheme, FP, ML, Miranda} and \textit{Haskell} aim to implement Church's lambda calculus in the form of a programming language which does everything needed by \textbf{composing functions}, thus no \textit{mutable \textbf{state}} and no \textit{side effects}.

FPL\footnote{Short for \textit{\textbf{F}unctional \textbf{P}rogramming \textbf{L}anguages}} needs some key features which are often absent in \textit{imperative} languages:
\begin{itemize}
   \item $1^{st}$-class order and \textbf{high-order} functions:
   Functions can be \textit{denoted}, passed as \textit{arguments} to other functions, \textit{returned} as result of function invocation
   \item \textbf{Recursion} opposed to \textit{"control variables"}
   \item \textbf{Powerful list facilities}: Recursive functions exploit recursive definition of lists
   \item \textbf{Polymorphism} typically universal parametric
   implicit, 
   which plays a key role when handling containers/collections.
   \item \textbf{Fully general aggregates}:
   there is a wide use of tuples and records,
   besides,
   data structures cannot be modified (\textit{no state!}), they have to be re-created.
   \item \textbf{Structured function returns} allow to pass more meaningful information to the caller, avoiding the need for "side-effects".
   \item \textbf{Gargabe collection}
\end{itemize}